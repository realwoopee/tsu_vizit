//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../api-client.types';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import * as Client from './Client'
export { Client };
import type { AxiosRequestConfig } from 'axios';

export type AbsenceAllQueryParameters = {
  createdById?: string | undefined ;
  finalisedById?: string | undefined ;
  finalStatus?: Types.AbsenceRequestResult | undefined ;
  reason?: Types.AbsenceReason | undefined ;
  sorting?: Types.AbsenceRequestSorting | undefined ;
  pagination_Offset?: number | undefined ;
  pagination_Limit?: number | undefined ;
}

export type AbsencePUTQueryParameters = {
  id: string ;
}

export type AbsenceDELETEQueryParameters = {
  id: string ;
}

export type StatusQueryParameters = {
  id: string ;
}


export type AllQueryParameters = {
  createdById?: string | undefined ;
  finalisedById?: string | undefined ;
  finalStatus?: Types.AbsenceRequestResult | undefined ;
  reason?: Types.AbsenceReason | undefined ;
}

export type MineQueryParameters = {
  finalisedById?: string | undefined ;
  finalStatus?: Types.AbsenceRequestResult | undefined ;
  reason?: Types.AbsenceReason | undefined ;
}

export type AttachQueryParameters = {
  absenceId: string ;
  file?: Types.FileParameter | undefined ;
}

export type AttachMutationParameters = {
  file?: Types.FileParameter | undefined ;
}


export type SessionQueryParameters = {
  id: string ;
}


export type ProfilePUT2QueryParameters = {
  id: string ;
}

export type RoleQueryParameters = {
  id: string ;
  userRole?: Types.UserRole | undefined ;
}

export type ProfilesQueryParameters = {
  studentIdNumber?: string | undefined ;
  fullName?: string | undefined ;
  email?: string | undefined ;
  role?: Types.UserRole | undefined ;
  sorting?: Types.UserSorting | undefined ;
  pagination_Offset?: number | undefined ;
  pagination_Limit?: number | undefined ;
}

export function absenceAllUrl(createdById?: string | undefined, finalisedById?: string | undefined, finalStatus?: Types.AbsenceRequestResult | undefined, reason?: Types.AbsenceReason | undefined, sorting?: Types.AbsenceRequestSorting | undefined, pagination_Offset?: number | undefined, pagination_Limit?: number | undefined): string {
  let url_ = getBaseUrl() + "/api/absence?";
if (createdById === null)
    throw new Error("The parameter 'createdById' cannot be null.");
else if (createdById !== undefined)
    url_ += "CreatedById=" + encodeURIComponent("" + createdById) + "&";
if (finalisedById === null)
    throw new Error("The parameter 'finalisedById' cannot be null.");
else if (finalisedById !== undefined)
    url_ += "FinalisedById=" + encodeURIComponent("" + finalisedById) + "&";
if (finalStatus === null)
    throw new Error("The parameter 'finalStatus' cannot be null.");
else if (finalStatus !== undefined)
    url_ += "FinalStatus=" + encodeURIComponent("" + finalStatus) + "&";
if (reason === null)
    throw new Error("The parameter 'reason' cannot be null.");
else if (reason !== undefined)
    url_ += "Reason=" + encodeURIComponent("" + reason) + "&";
if (sorting === null)
    throw new Error("The parameter 'sorting' cannot be null.");
else if (sorting !== undefined)
    url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
if (pagination_Offset === null)
    throw new Error("The parameter 'pagination_Offset' cannot be null.");
else if (pagination_Offset !== undefined)
    url_ += "Pagination.Offset=" + encodeURIComponent("" + pagination_Offset) + "&";
if (pagination_Limit === null)
    throw new Error("The parameter 'pagination_Limit' cannot be null.");
else if (pagination_Limit !== undefined)
    url_ += "Pagination.Limit=" + encodeURIComponent("" + pagination_Limit) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let absenceAllDefaultOptions: Omit<UseQueryOptions<Types.AbsenceRequestDto[], unknown, Types.AbsenceRequestDto[]>, 'queryKey'> = {
  queryFn: __absenceAll,
};
export function getAbsenceAllDefaultOptions() {
  return absenceAllDefaultOptions;
};
export function setAbsenceAllDefaultOptions(options: typeof absenceAllDefaultOptions) {
  absenceAllDefaultOptions = options;
}

export function absenceAllQueryKey(dto: AbsenceAllQueryParameters): QueryKey;
export function absenceAllQueryKey(createdById?: string | undefined, finalisedById?: string | undefined, finalStatus?: Types.AbsenceRequestResult | undefined, reason?: Types.AbsenceReason | undefined, sorting?: Types.AbsenceRequestSorting | undefined, pagination_Offset?: number | undefined, pagination_Limit?: number | undefined): QueryKey;
export function absenceAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { createdById, finalisedById, finalStatus, reason, sorting, pagination_Offset, pagination_Limit,  } = params[0] as AbsenceAllQueryParameters;

    return trimArrayEnd([
        'Client',
        'absenceAll',
        createdById as any,
        finalisedById as any,
        finalStatus as any,
        reason as any,
        sorting as any,
        pagination_Offset as any,
        pagination_Limit as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'absenceAll',
        ...params
      ]);
  }
}
function __absenceAll(context: QueryFunctionContext) {
  return Client.absenceAll(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as Types.AbsenceRequestResult | undefined,       context.queryKey[5] as Types.AbsenceReason | undefined,       context.queryKey[6] as Types.AbsenceRequestSorting | undefined,       context.queryKey[7] as number | undefined,       context.queryKey[8] as number | undefined    );
}

export function useAbsenceAllQuery<TSelectData = Types.AbsenceRequestDto[], TError = unknown>(dto: AbsenceAllQueryParameters, options?: Omit<UseQueryOptions<Types.AbsenceRequestDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param createdById (optional) 
 * @param finalisedById (optional) 
 * @param finalStatus (optional) 
 * @param reason (optional) 
 * @param sorting (optional) 
 * @param pagination_Offset (optional) 
 * @param pagination_Limit (optional) 
 * @return OK
 */
export function useAbsenceAllQuery<TSelectData = Types.AbsenceRequestDto[], TError = unknown>(createdById?: string | undefined, finalisedById?: string | undefined, finalStatus?: Types.AbsenceRequestResult | undefined, reason?: Types.AbsenceReason | undefined, sorting?: Types.AbsenceRequestSorting | undefined, pagination_Offset?: number | undefined, pagination_Limit?: number | undefined, options?: Omit<UseQueryOptions<Types.AbsenceRequestDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useAbsenceAllQuery<TSelectData = Types.AbsenceRequestDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.AbsenceRequestDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let createdById: any = undefined;
  let finalisedById: any = undefined;
  let finalStatus: any = undefined;
  let reason: any = undefined;
  let sorting: any = undefined;
  let pagination_Offset: any = undefined;
  let pagination_Limit: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ createdById, finalisedById, finalStatus, reason, sorting, pagination_Offset, pagination_Limit,  } = params[0] as AbsenceAllQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [createdById, finalisedById, finalStatus, reason, sorting, pagination_Offset, pagination_Limit, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.AbsenceRequestDto[], TError, TSelectData>({
    queryFn: __absenceAll,
    queryKey: absenceAllQueryKey(createdById, finalisedById, finalStatus, reason, sorting, pagination_Offset, pagination_Limit),
    ...absenceAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.AbsenceRequestDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param createdById (optional) 
 * @param finalisedById (optional) 
 * @param finalStatus (optional) 
 * @param reason (optional) 
 * @param sorting (optional) 
 * @param pagination_Offset (optional) 
 * @param pagination_Limit (optional) 
 * @return OK
 */
export function setAbsenceAllData(queryClient: QueryClient, updater: (data: Types.AbsenceRequestDto[] | undefined) => Types.AbsenceRequestDto[], createdById?: string | undefined, finalisedById?: string | undefined, finalStatus?: Types.AbsenceRequestResult | undefined, reason?: Types.AbsenceReason | undefined, sorting?: Types.AbsenceRequestSorting | undefined, pagination_Offset?: number | undefined, pagination_Limit?: number | undefined) {
  queryClient.setQueryData(absenceAllQueryKey(createdById, finalisedById, finalStatus, reason, sorting, pagination_Offset, pagination_Limit),
    updater
  );
}

/**
 * @param createdById (optional) 
 * @param finalisedById (optional) 
 * @param finalStatus (optional) 
 * @param reason (optional) 
 * @param sorting (optional) 
 * @param pagination_Offset (optional) 
 * @param pagination_Limit (optional) 
 * @return OK
 */
export function setAbsenceAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.AbsenceRequestDto[] | undefined) => Types.AbsenceRequestDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function absencePOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/absence";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function absencePOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'absencePOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useAbsencePOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AbsenceRequestDto, unknown, Types.CreateAbsenceRequestModel, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AbsenceRequestDto, unknown, Types.CreateAbsenceRequestModel, TContext> {
  const key = absencePOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.CreateAbsenceRequestModel) => Client.absencePOST(body),
    mutationKey: key,
  });
}
  
export function absencePUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/absence/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function absencePUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'absencePUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useAbsencePUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.AbsenceRequestDto, unknown, Types.EditAbsenceRequestModel, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AbsenceRequestDto, unknown, Types.EditAbsenceRequestModel, TContext> {
  const key = absencePUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.EditAbsenceRequestModel) => Client.absencePUT(id, body),
    mutationKey: key,
  });
}
  
type AbsencePUT__MutationParameters = AbsencePUTQueryParameters & {
  body: Types.EditAbsenceRequestModel;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useAbsencePUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.AbsenceRequestDto, unknown, AbsencePUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: AbsencePUTQueryParameters}): UseMutationResult<Types.AbsenceRequestDto, unknown, AbsencePUT__MutationParameters, TContext> {
  const key = absencePUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: AbsencePUT__MutationParameters) => Client.absencePUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function absenceDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/absence/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function absenceDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'absenceDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useAbsenceDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.AbsenceRequestDto, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AbsenceRequestDto, unknown, void, TContext> {
  const key = absenceDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.absenceDELETE(id),
    mutationKey: key,
  });
}
  
type AbsenceDELETE__MutationParameters = AbsenceDELETEQueryParameters

/**
 * @return OK
 */
export function useAbsenceDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.AbsenceRequestDto, unknown, AbsenceDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: AbsenceDELETEQueryParameters}): UseMutationResult<Types.AbsenceRequestDto, unknown, AbsenceDELETE__MutationParameters, TContext> {
  const key = absenceDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: AbsenceDELETE__MutationParameters) => Client.absenceDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function statusUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/absence/{id}/status";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function statusMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'status',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useStatusMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.AbsenceRequestDto, unknown, Types.EditAbsenceRequestStatusDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AbsenceRequestDto, unknown, Types.EditAbsenceRequestStatusDto, TContext> {
  const key = statusMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.EditAbsenceRequestStatusDto) => Client.status(id, body),
    mutationKey: key,
  });
}
  
type Status__MutationParameters = StatusQueryParameters & {
  body: Types.EditAbsenceRequestStatusDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useStatusMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.AbsenceRequestDto, unknown, Status__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: StatusQueryParameters}): UseMutationResult<Types.AbsenceRequestDto, unknown, Status__MutationParameters, TContext> {
  const key = statusMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Status__MutationParameters) => Client.status(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function loginUrl(): string {
  let url_ = getBaseUrl() + "/api/auth/login";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function loginMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'login',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useLoginMutation<TContext>(options?: Omit<UseMutationOptions<Types.LoginResultDto, unknown, Types.UserLoginModel, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.LoginResultDto, unknown, Types.UserLoginModel, TContext> {
  const key = loginMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.UserLoginModel) => Client.login(body),
    mutationKey: key,
  });
}
  
export function refreshUrl(): string {
  let url_ = getBaseUrl() + "/api/auth/refresh";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function refreshMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'refresh',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useRefreshMutation<TContext>(options?: Omit<UseMutationOptions<Types.LoginResultDto, unknown, string, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.LoginResultDto, unknown, string, TContext> {
  const key = refreshMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: string) => Client.refresh(body),
    mutationKey: key,
  });
}
  
export function changePasswordUrl(): string {
  let url_ = getBaseUrl() + "/api/auth/change-password";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function changePasswordMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'changePassword',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useChangePasswordMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.UserChangePasswordModel, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.UserChangePasswordModel, TContext> {
  const key = changePasswordMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.UserChangePasswordModel) => Client.changePassword(body),
    mutationKey: key,
  });
}
  
export function allUrl(createdById?: string | undefined, finalisedById?: string | undefined, finalStatus?: Types.AbsenceRequestResult | undefined, reason?: Types.AbsenceReason | undefined): string {
  let url_ = getBaseUrl() + "/api/export/absence_request/all?";
if (createdById === null)
    throw new Error("The parameter 'createdById' cannot be null.");
else if (createdById !== undefined)
    url_ += "CreatedById=" + encodeURIComponent("" + createdById) + "&";
if (finalisedById === null)
    throw new Error("The parameter 'finalisedById' cannot be null.");
else if (finalisedById !== undefined)
    url_ += "FinalisedById=" + encodeURIComponent("" + finalisedById) + "&";
if (finalStatus === null)
    throw new Error("The parameter 'finalStatus' cannot be null.");
else if (finalStatus !== undefined)
    url_ += "FinalStatus=" + encodeURIComponent("" + finalStatus) + "&";
if (reason === null)
    throw new Error("The parameter 'reason' cannot be null.");
else if (reason !== undefined)
    url_ += "Reason=" + encodeURIComponent("" + reason) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let allDefaultOptions: Omit<UseQueryOptions<void, unknown, void>, 'queryKey'> = {
  queryFn: __all,
};
export function getAllDefaultOptions() {
  return allDefaultOptions;
};
export function setAllDefaultOptions(options: typeof allDefaultOptions) {
  allDefaultOptions = options;
}

export function allQueryKey(dto: AllQueryParameters): QueryKey;
export function allQueryKey(createdById?: string | undefined, finalisedById?: string | undefined, finalStatus?: Types.AbsenceRequestResult | undefined, reason?: Types.AbsenceReason | undefined): QueryKey;
export function allQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { createdById, finalisedById, finalStatus, reason,  } = params[0] as AllQueryParameters;

    return trimArrayEnd([
        'Client',
        'all',
        createdById as any,
        finalisedById as any,
        finalStatus as any,
        reason as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'all',
        ...params
      ]);
  }
}
function __all(context: QueryFunctionContext) {
  return Client.all(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as Types.AbsenceRequestResult | undefined,       context.queryKey[5] as Types.AbsenceReason | undefined    );
}

export function useAllQuery<TSelectData = void, TError = unknown>(dto: AllQueryParameters, options?: Omit<UseQueryOptions<void, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param createdById (optional) 
 * @param finalisedById (optional) 
 * @param finalStatus (optional) 
 * @param reason (optional) 
 * @return OK
 */
export function useAllQuery<TSelectData = void, TError = unknown>(createdById?: string | undefined, finalisedById?: string | undefined, finalStatus?: Types.AbsenceRequestResult | undefined, reason?: Types.AbsenceReason | undefined, options?: Omit<UseQueryOptions<void, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useAllQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let createdById: any = undefined;
  let finalisedById: any = undefined;
  let finalStatus: any = undefined;
  let reason: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ createdById, finalisedById, finalStatus, reason,  } = params[0] as AllQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [createdById, finalisedById, finalStatus, reason, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<void, TError, TSelectData>({
    queryFn: __all,
    queryKey: allQueryKey(createdById, finalisedById, finalStatus, reason),
    ...allDefaultOptions as unknown as Omit<UseQueryOptions<void, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param createdById (optional) 
 * @param finalisedById (optional) 
 * @param finalStatus (optional) 
 * @param reason (optional) 
 * @return OK
 */
export function setAllData(queryClient: QueryClient, updater: (data: void | undefined) => void, createdById?: string | undefined, finalisedById?: string | undefined, finalStatus?: Types.AbsenceRequestResult | undefined, reason?: Types.AbsenceReason | undefined) {
  queryClient.setQueryData(allQueryKey(createdById, finalisedById, finalStatus, reason),
    updater
  );
}

/**
 * @param createdById (optional) 
 * @param finalisedById (optional) 
 * @param finalStatus (optional) 
 * @param reason (optional) 
 * @return OK
 */
export function setAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function mineUrl(finalisedById?: string | undefined, finalStatus?: Types.AbsenceRequestResult | undefined, reason?: Types.AbsenceReason | undefined): string {
  let url_ = getBaseUrl() + "/api/export/absence_request/mine?";
if (finalisedById === null)
    throw new Error("The parameter 'finalisedById' cannot be null.");
else if (finalisedById !== undefined)
    url_ += "FinalisedById=" + encodeURIComponent("" + finalisedById) + "&";
if (finalStatus === null)
    throw new Error("The parameter 'finalStatus' cannot be null.");
else if (finalStatus !== undefined)
    url_ += "FinalStatus=" + encodeURIComponent("" + finalStatus) + "&";
if (reason === null)
    throw new Error("The parameter 'reason' cannot be null.");
else if (reason !== undefined)
    url_ += "Reason=" + encodeURIComponent("" + reason) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let mineDefaultOptions: Omit<UseQueryOptions<void, unknown, void>, 'queryKey'> = {
  queryFn: __mine,
};
export function getMineDefaultOptions() {
  return mineDefaultOptions;
};
export function setMineDefaultOptions(options: typeof mineDefaultOptions) {
  mineDefaultOptions = options;
}

export function mineQueryKey(dto: MineQueryParameters): QueryKey;
export function mineQueryKey(finalisedById?: string | undefined, finalStatus?: Types.AbsenceRequestResult | undefined, reason?: Types.AbsenceReason | undefined): QueryKey;
export function mineQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { finalisedById, finalStatus, reason,  } = params[0] as MineQueryParameters;

    return trimArrayEnd([
        'Client',
        'mine',
        finalisedById as any,
        finalStatus as any,
        reason as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'mine',
        ...params
      ]);
  }
}
function __mine(context: QueryFunctionContext) {
  return Client.mine(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as Types.AbsenceRequestResult | undefined,       context.queryKey[4] as Types.AbsenceReason | undefined    );
}

export function useMineQuery<TSelectData = void, TError = unknown>(dto: MineQueryParameters, options?: Omit<UseQueryOptions<void, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param finalisedById (optional) 
 * @param finalStatus (optional) 
 * @param reason (optional) 
 * @return OK
 */
export function useMineQuery<TSelectData = void, TError = unknown>(finalisedById?: string | undefined, finalStatus?: Types.AbsenceRequestResult | undefined, reason?: Types.AbsenceReason | undefined, options?: Omit<UseQueryOptions<void, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMineQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let finalisedById: any = undefined;
  let finalStatus: any = undefined;
  let reason: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ finalisedById, finalStatus, reason,  } = params[0] as MineQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [finalisedById, finalStatus, reason, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<void, TError, TSelectData>({
    queryFn: __mine,
    queryKey: mineQueryKey(finalisedById, finalStatus, reason),
    ...mineDefaultOptions as unknown as Omit<UseQueryOptions<void, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param finalisedById (optional) 
 * @param finalStatus (optional) 
 * @param reason (optional) 
 * @return OK
 */
export function setMineData(queryClient: QueryClient, updater: (data: void | undefined) => void, finalisedById?: string | undefined, finalStatus?: Types.AbsenceRequestResult | undefined, reason?: Types.AbsenceReason | undefined) {
  queryClient.setQueryData(mineQueryKey(finalisedById, finalStatus, reason),
    updater
  );
}

/**
 * @param finalisedById (optional) 
 * @param finalStatus (optional) 
 * @param reason (optional) 
 * @return OK
 */
export function setMineDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function attachUrl(absenceId: string): string {
  let url_ = getBaseUrl() + "/api/absence/{absenceId}/attach";
if (absenceId === undefined || absenceId === null)
  throw new Error("The parameter 'absenceId' must be defined.");
url_ = url_.replace("{absenceId}", encodeURIComponent("" + absenceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function attachMutationKey(absenceId: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'attach',
      absenceId as any,
    ]);
}

/**
 * @param file (optional) 
 * @return OK
 */
export function useAttachMutation<TContext>(absenceId: string, options?: Omit<UseMutationOptions<Types.Document, unknown, AttachMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Document, unknown, AttachMutationParameters, TContext> {
  const key = attachMutationKey(absenceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (attachMutationParameters: AttachMutationParameters) => Client.attach(absenceId, attachMutationParameters.file),
    mutationKey: key,
  });
}
  
type Attach__MutationParameters = AttachQueryParameters & {
  attachMutationParameters: AttachMutationParameters;
}

/**
 * @param file (optional) 
 * @return OK
 */
export function useAttachMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.Document, unknown, Attach__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: AttachQueryParameters}): UseMutationResult<Types.Document, unknown, Attach__MutationParameters, TContext> {
  const key = attachMutationKey(options?.parameters?.absenceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options, 
    mutationFn: (data: Attach__MutationParameters) => Client.attach(data.absenceId, data.file),
    mutationKey: key,
  });
}
  
export function registerUrl(): string {
  let url_ = getBaseUrl() + "/api/register";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function registerMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'register',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useRegisterMutation<TContext>(options?: Omit<UseMutationOptions<Types.LoginResultDto, unknown, Types.UserRegisterModel, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.LoginResultDto, unknown, Types.UserRegisterModel, TContext> {
  const key = registerMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.UserRegisterModel) => Client.register(body),
    mutationKey: key,
  });
}
  
export function sessionAllUrl(): string {
  let url_ = getBaseUrl() + "/api/session";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let sessionAllDefaultOptions: Omit<UseQueryOptions<Types.SessionDto[], unknown, Types.SessionDto[]>, 'queryKey'> = {
  queryFn: __sessionAll,
};
export function getSessionAllDefaultOptions() {
  return sessionAllDefaultOptions;
};
export function setSessionAllDefaultOptions(options: typeof sessionAllDefaultOptions) {
  sessionAllDefaultOptions = options;
}

export function sessionAllQueryKey(): QueryKey;
export function sessionAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'sessionAll',
    ]);
}
function __sessionAll() {
  return Client.sessionAll(
    );
}

/**
 * @return OK
 */
export function useSessionAllQuery<TSelectData = Types.SessionDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.SessionDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSessionAllQuery<TSelectData = Types.SessionDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SessionDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.SessionDto[], TError, TSelectData>({
    queryFn: __sessionAll,
    queryKey: sessionAllQueryKey(),
    ...sessionAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.SessionDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setSessionAllData(queryClient: QueryClient, updater: (data: Types.SessionDto[] | undefined) => Types.SessionDto[], ) {
  queryClient.setQueryData(sessionAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setSessionAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SessionDto[] | undefined) => Types.SessionDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function currentUrl(): string {
  let url_ = getBaseUrl() + "/api/session/current";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let currentDefaultOptions: Omit<UseQueryOptions<Types.SessionDto[], unknown, Types.SessionDto[]>, 'queryKey'> = {
  queryFn: __current,
};
export function getCurrentDefaultOptions() {
  return currentDefaultOptions;
};
export function setCurrentDefaultOptions(options: typeof currentDefaultOptions) {
  currentDefaultOptions = options;
}

export function currentQueryKey(): QueryKey;
export function currentQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'current',
    ]);
}
function __current() {
  return Client.current(
    );
}

/**
 * @return OK
 */
export function useCurrentQuery<TSelectData = Types.SessionDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.SessionDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useCurrentQuery<TSelectData = Types.SessionDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SessionDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.SessionDto[], TError, TSelectData>({
    queryFn: __current,
    queryKey: currentQueryKey(),
    ...currentDefaultOptions as unknown as Omit<UseQueryOptions<Types.SessionDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setCurrentData(queryClient: QueryClient, updater: (data: Types.SessionDto[] | undefined) => Types.SessionDto[], ) {
  queryClient.setQueryData(currentQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setCurrentDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SessionDto[] | undefined) => Types.SessionDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function sessionUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/session/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function sessionMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'session',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useSessionMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = sessionMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.session(id),
    mutationKey: key,
  });
}
  
type Session__MutationParameters = SessionQueryParameters

/**
 * @return OK
 */
export function useSessionMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, Session__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: SessionQueryParameters}): UseMutationResult<void, unknown, Session__MutationParameters, TContext> {
  const key = sessionMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Session__MutationParameters) => Client.session(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function permissionsUrl(): string {
  let url_ = getBaseUrl() + "/api/account/permissions";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let permissionsDefaultOptions: Omit<UseQueryOptions<Types.UserPermissionsDto, unknown, Types.UserPermissionsDto>, 'queryKey'> = {
  queryFn: __permissions,
};
export function getPermissionsDefaultOptions() {
  return permissionsDefaultOptions;
};
export function setPermissionsDefaultOptions(options: typeof permissionsDefaultOptions) {
  permissionsDefaultOptions = options;
}

export function permissionsQueryKey(): QueryKey;
export function permissionsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'permissions',
    ]);
}
function __permissions() {
  return Client.permissions(
    );
}

/**
 * @return OK
 */
export function usePermissionsQuery<TSelectData = Types.UserPermissionsDto, TError = unknown>(options?: Omit<UseQueryOptions<Types.UserPermissionsDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function usePermissionsQuery<TSelectData = Types.UserPermissionsDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserPermissionsDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.UserPermissionsDto, TError, TSelectData>({
    queryFn: __permissions,
    queryKey: permissionsQueryKey(),
    ...permissionsDefaultOptions as unknown as Omit<UseQueryOptions<Types.UserPermissionsDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setPermissionsData(queryClient: QueryClient, updater: (data: Types.UserPermissionsDto | undefined) => Types.UserPermissionsDto, ) {
  queryClient.setQueryData(permissionsQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setPermissionsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserPermissionsDto | undefined) => Types.UserPermissionsDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function profileGETUrl(): string {
  let url_ = getBaseUrl() + "/api/account/profile";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let profileGETDefaultOptions: Omit<UseQueryOptions<Types.UserDto, unknown, Types.UserDto>, 'queryKey'> = {
  queryFn: __profileGET,
};
export function getProfileGETDefaultOptions() {
  return profileGETDefaultOptions;
};
export function setProfileGETDefaultOptions(options: typeof profileGETDefaultOptions) {
  profileGETDefaultOptions = options;
}

export function profileGETQueryKey(): QueryKey;
export function profileGETQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'profileGET',
    ]);
}
function __profileGET() {
  return Client.profileGET(
    );
}

/**
 * @return OK
 */
export function useProfileGETQuery<TSelectData = Types.UserDto, TError = unknown>(options?: Omit<UseQueryOptions<Types.UserDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useProfileGETQuery<TSelectData = Types.UserDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.UserDto, TError, TSelectData>({
    queryFn: __profileGET,
    queryKey: profileGETQueryKey(),
    ...profileGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.UserDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setProfileGETData(queryClient: QueryClient, updater: (data: Types.UserDto | undefined) => Types.UserDto, ) {
  queryClient.setQueryData(profileGETQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setProfileGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserDto | undefined) => Types.UserDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function profilePUTUrl(): string {
  let url_ = getBaseUrl() + "/api/account/profile";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function profilePUTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'profilePUT',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useProfilePUTMutation<TContext>(options?: Omit<UseMutationOptions<Types.UserDto, unknown, Types.UserEditProfileModel, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.UserDto, unknown, Types.UserEditProfileModel, TContext> {
  const key = profilePUTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.UserEditProfileModel) => Client.profilePUT(body),
    mutationKey: key,
  });
}
  
export function profilePUT2Url(id: string): string {
  let url_ = getBaseUrl() + "/api/account/{id}/profile";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function profilePUT2MutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'profilePUT2',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useProfilePUT2Mutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.UserDto, unknown, Types.UserEditProfileModel, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.UserDto, unknown, Types.UserEditProfileModel, TContext> {
  const key = profilePUT2MutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.UserEditProfileModel) => Client.profilePUT2(id, body),
    mutationKey: key,
  });
}
  
type ProfilePUT2__MutationParameters = ProfilePUT2QueryParameters & {
  body: Types.UserEditProfileModel;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useProfilePUT2MutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.UserDto, unknown, ProfilePUT2__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ProfilePUT2QueryParameters}): UseMutationResult<Types.UserDto, unknown, ProfilePUT2__MutationParameters, TContext> {
  const key = profilePUT2MutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ProfilePUT2__MutationParameters) => Client.profilePUT2(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function roleUrl(id: string, userRole?: Types.UserRole | undefined): string {
  let url_ = getBaseUrl() + "/api/account/{id}/profile/role?";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
if (userRole === null)
    throw new Error("The parameter 'userRole' cannot be null.");
else if (userRole !== undefined)
    url_ += "userRole=" + encodeURIComponent("" + userRole) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function roleMutationKey(id: string, userRole?: Types.UserRole | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'role',
      id as any,
      userRole as any,
    ]);
}

/**
 * @param userRole (optional) 
 * @return OK
 */
export function useRoleMutation<TContext>(id: string, userRole?: Types.UserRole | undefined, options?: Omit<UseMutationOptions<Types.UserPermissionsDto, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.UserPermissionsDto, unknown, void, TContext> {
  const key = roleMutationKey(id, userRole);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.role(id, userRole),
    mutationKey: key,
  });
}
  
type Role__MutationParameters = RoleQueryParameters

/**
 * @param userRole (optional) 
 * @return OK
 */
export function useRoleMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.UserPermissionsDto, unknown, Role__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: RoleQueryParameters}): UseMutationResult<Types.UserPermissionsDto, unknown, Role__MutationParameters, TContext> {
  const key = roleMutationKey(options?.parameters?.id!, options?.parameters?.userRole!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Role__MutationParameters) => Client.role(data.id ?? options?.parameters?.id!, data.userRole ?? options?.parameters?.userRole!),
  mutationKey: key,
});
}
  
export function profilesUrl(studentIdNumber?: string | undefined, fullName?: string | undefined, email?: string | undefined, role?: Types.UserRole | undefined, sorting?: Types.UserSorting | undefined, pagination_Offset?: number | undefined, pagination_Limit?: number | undefined): string {
  let url_ = getBaseUrl() + "/api/account/profiles?";
if (studentIdNumber === null)
    throw new Error("The parameter 'studentIdNumber' cannot be null.");
else if (studentIdNumber !== undefined)
    url_ += "StudentIdNumber=" + encodeURIComponent("" + studentIdNumber) + "&";
if (fullName === null)
    throw new Error("The parameter 'fullName' cannot be null.");
else if (fullName !== undefined)
    url_ += "FullName=" + encodeURIComponent("" + fullName) + "&";
if (email === null)
    throw new Error("The parameter 'email' cannot be null.");
else if (email !== undefined)
    url_ += "Email=" + encodeURIComponent("" + email) + "&";
if (role === null)
    throw new Error("The parameter 'role' cannot be null.");
else if (role !== undefined)
    url_ += "Role=" + encodeURIComponent("" + role) + "&";
if (sorting === null)
    throw new Error("The parameter 'sorting' cannot be null.");
else if (sorting !== undefined)
    url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
if (pagination_Offset === null)
    throw new Error("The parameter 'pagination_Offset' cannot be null.");
else if (pagination_Offset !== undefined)
    url_ += "Pagination.Offset=" + encodeURIComponent("" + pagination_Offset) + "&";
if (pagination_Limit === null)
    throw new Error("The parameter 'pagination_Limit' cannot be null.");
else if (pagination_Limit !== undefined)
    url_ += "Pagination.Limit=" + encodeURIComponent("" + pagination_Limit) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let profilesDefaultOptions: Omit<UseQueryOptions<Types.UserDto[], unknown, Types.UserDto[]>, 'queryKey'> = {
  queryFn: __profiles,
};
export function getProfilesDefaultOptions() {
  return profilesDefaultOptions;
};
export function setProfilesDefaultOptions(options: typeof profilesDefaultOptions) {
  profilesDefaultOptions = options;
}

export function profilesQueryKey(dto: ProfilesQueryParameters): QueryKey;
export function profilesQueryKey(studentIdNumber?: string | undefined, fullName?: string | undefined, email?: string | undefined, role?: Types.UserRole | undefined, sorting?: Types.UserSorting | undefined, pagination_Offset?: number | undefined, pagination_Limit?: number | undefined): QueryKey;
export function profilesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { studentIdNumber, fullName, email, role, sorting, pagination_Offset, pagination_Limit,  } = params[0] as ProfilesQueryParameters;

    return trimArrayEnd([
        'Client',
        'profiles',
        studentIdNumber as any,
        fullName as any,
        email as any,
        role as any,
        sorting as any,
        pagination_Offset as any,
        pagination_Limit as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'profiles',
        ...params
      ]);
  }
}
function __profiles(context: QueryFunctionContext) {
  return Client.profiles(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as string | undefined,       context.queryKey[5] as Types.UserRole | undefined,       context.queryKey[6] as Types.UserSorting | undefined,       context.queryKey[7] as number | undefined,       context.queryKey[8] as number | undefined    );
}

export function useProfilesQuery<TSelectData = Types.UserDto[], TError = unknown>(dto: ProfilesQueryParameters, options?: Omit<UseQueryOptions<Types.UserDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param studentIdNumber (optional) 
 * @param fullName (optional) 
 * @param email (optional) 
 * @param role (optional) 
 * @param sorting (optional) 
 * @param pagination_Offset (optional) 
 * @param pagination_Limit (optional) 
 * @return OK
 */
export function useProfilesQuery<TSelectData = Types.UserDto[], TError = unknown>(studentIdNumber?: string | undefined, fullName?: string | undefined, email?: string | undefined, role?: Types.UserRole | undefined, sorting?: Types.UserSorting | undefined, pagination_Offset?: number | undefined, pagination_Limit?: number | undefined, options?: Omit<UseQueryOptions<Types.UserDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useProfilesQuery<TSelectData = Types.UserDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let studentIdNumber: any = undefined;
  let fullName: any = undefined;
  let email: any = undefined;
  let role: any = undefined;
  let sorting: any = undefined;
  let pagination_Offset: any = undefined;
  let pagination_Limit: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ studentIdNumber, fullName, email, role, sorting, pagination_Offset, pagination_Limit,  } = params[0] as ProfilesQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [studentIdNumber, fullName, email, role, sorting, pagination_Offset, pagination_Limit, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.UserDto[], TError, TSelectData>({
    queryFn: __profiles,
    queryKey: profilesQueryKey(studentIdNumber, fullName, email, role, sorting, pagination_Offset, pagination_Limit),
    ...profilesDefaultOptions as unknown as Omit<UseQueryOptions<Types.UserDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param studentIdNumber (optional) 
 * @param fullName (optional) 
 * @param email (optional) 
 * @param role (optional) 
 * @param sorting (optional) 
 * @param pagination_Offset (optional) 
 * @param pagination_Limit (optional) 
 * @return OK
 */
export function setProfilesData(queryClient: QueryClient, updater: (data: Types.UserDto[] | undefined) => Types.UserDto[], studentIdNumber?: string | undefined, fullName?: string | undefined, email?: string | undefined, role?: Types.UserRole | undefined, sorting?: Types.UserSorting | undefined, pagination_Offset?: number | undefined, pagination_Limit?: number | undefined) {
  queryClient.setQueryData(profilesQueryKey(studentIdNumber, fullName, email, role, sorting, pagination_Offset, pagination_Limit),
    updater
  );
}

/**
 * @param studentIdNumber (optional) 
 * @param fullName (optional) 
 * @param email (optional) 
 * @param role (optional) 
 * @param sorting (optional) 
 * @param pagination_Offset (optional) 
 * @param pagination_Limit (optional) 
 * @return OK
 */
export function setProfilesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserDto[] | undefined) => Types.UserDto[]) {
  queryClient.setQueryData(queryKey, updater);
}